import sys

sys.stdin = open("_Flatten.txt")

# 한쪽 벽 면에 다음과 같이 노란색 상자들이 쌓여있음
# 높은 곳의 상자를 낮은 곳에 옮기는 방식으로 최고점과 최저점의 간격을 줄이는 작업을 평탄화라고 함
# 평탄화를 모두 수행하고 나면, 가장 높은 곳과 가장 낮은 곳의 차이가 최대 1 이내가 됨
# 평탄화 작업을 위해서 상자를 옮기는 작업 횟수에 제한이 걸려있을 때, 제한된 횟수만큼 옮기는 작업을 한 후 최고점과 최저점의 차이를 반환하는 프로그램 작성
# 가장 



T = 10

for tc in range(1, T+1):
    N = int(input())  # 덤프횟수
    box_lst = list(map(int, input().split())) # 각 상자의 높이값 

    # 각 층마다 몇개가 있는지 카운팅
    cnt = [0] * 101 # 가로길이: 인덱스 0부터 있으니깐 숫자와 맞출려면 101개 만들어야함
    for i in box_lst: # range가 없을 경우, i에는 상자 높이 값가 들어가서 그 요소를 순차적으로 반복
        cnt[i] += 1 # cnt 인덱스 자리에 1 추가
    # cnt 리스트 안에 각 박스 리스트 요소 숫자 인덱스에 1이 추가 됨

    # 항상 상자 높이 1 이상 100 이하니까
    min = 101
    max = 0
    for box in box_lst: # 여기서 box는 박스리스트 요소들 => 상자 높이 값
        if box < min:
            min = box # 상자 높이 값들이 101보다 작으면 min 숫자는 박스리스트 요소가 됨
        if box > max:
            max = box  # 상자 높이 값들이 0보다 크면 max가 박스리스트 요소가 됨

    
    # max 높이에서 1개 빼주고 그걸 min 높이에 더해줌 -> 카운팅이 바뀜
    # 근데 그렇게 하면 min, max 높이가 달라지므로 같이 체크해줌
    n = 0
    while n < N: # 덤프횟수 만큼 반복문 돌려줌
        cnt[max] -= 1 # cnt리스트에서 max 인덱스의 값에 -1
        cnt[max-1] += 1 # cnt리스트에서 max 인덱스 값보다 한개 작은 기둥을 +1 
        cnt[min] -= 1 # cnt리스트에서 min 인덱스 값에서 -1
        cnt[min+1] += 1 # cnt리스트에서 min 인덱스 값보다 한개 큰 기둥을 +1
        # 1) 제일 큰 높이의 인덱스 값에서 -1 => 예를들어 문제 예시처럼 9높이의(9번째 자리) 기둥 체크를 없앰
        # 2) 그리고 그 옆의 8번쨰 높이(8번째 자리) 기둥에 체크를 해줌(두번째로 높은 기둥)
        # 3) 그리고 1높이의 가장 낮은 기둥체크를 없앰
        # 4) 마지막으로 2높이 기둥 체크에 체크를 해줌


        # max, min 높이인 애들의 개수가 0개면 안되니까 0 아닐 때까지 찾아서 값 체인지
        while cnt[max] == 0: # cnt리스트의 max 인덱스(98) 요소가 0이면 
            max -= 1 # max 숫자에서 -1해서 97 => 다시 와일문 조건으로 돌아가지만, 이미 맥스값은 -1이 되어서 97 그 숫자의 인덱스는 0이 아님
        while cnt[min] == 0: # cnt 리스트에서 min 인덱스(5)의 요소가 0이면
            min += 1 # 0이라서 min 값에서 +1해서 6이 됨 => 6은 0이 아니라서 반복문 빠져나감

        n += 1  # while문 빠져나가기 위해서 1씩 더해줌
    result = max - min # 주어진 덤프제한 횟수가 초과되어서 와일문에서 빠져나가게 되면 여기서 max값과 min값을 빼줌 => 최고점과 최저점의 높이 차 

    print("#{} {}".format(tc, result))



    
    